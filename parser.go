package main

import (
	"fmt"
	"go/parser"
	"go/token"
	"strings"
)

const (
	EnumCommentStart  = "Enum: "
	FieldCommentStart = "Field: "
	ValueCommentStart = "Value: "
	GeneratedMessage  = "Code generated by Genum DO NOT EDIT"
	Separator         = "->"
)

func parseSource(sourceFilePath string) ([]EnumType, error) {
	parsedFile, err := parser.ParseFile(token.NewFileSet(), sourceFilePath, nil, parser.ParseComments)
	if err != nil {
		return nil, err
	}
	parsedEnums := make([]EnumType, 0)
	for _, comment := range parsedFile.Comments {
		enums, err := commentToEnumType(comment.Text())
		if err != nil {
			return nil, err
		}
		parsedEnums = append(parsedEnums, enums...)
	}

	return parsedEnums, nil
}

func commentToEnumType(comment string) ([]EnumType, error) {
	enums := make([]EnumType, 0)
	lines := strings.Split(comment, "\n")
	enumStartIndexes := make([]int, 0)
	for i := 0; i < len(lines); i++ {
		if strings.HasPrefix(lines[i], EnumCommentStart) {
			enumStartIndexes = append(enumStartIndexes, i)
		}
	}

	if len(enumStartIndexes) != 0 {
		for i := 0; i < len(enumStartIndexes); i++ {
			start := enumStartIndexes[i]
			end := len(lines)

			if i != len(enumStartIndexes)-1 {
				end = enumStartIndexes[i+1]
			}

			emum, err := parseEmum(lines[start:end])
			if err != nil {
				return nil, err
			}
			enums = append(enums, emum)
		}
	}

	return enums, nil
}

func parseEmum(lines []string) (EnumType, error) {
	e := EnumType{
		fields:     make(FieldTypes, 0),
		enumValues: make(EnumValues, 0),
	}
	e.addDefaultTypes()
	e.name = parseEnumName(lines[0])
	PrintSuccess(fmt.Sprintf("%s type is found", e.name))
	valueCount := 0
	for j := 1; j < len(lines); j++ {
		if strings.HasPrefix(lines[j], FieldCommentStart) {
			field, err := parseField(lines[j])
			if err != nil {
				return EnumType{}, err
			}
			e.fields = append(e.fields, field)
		} else if strings.HasPrefix(lines[j], ValueCommentStart) {
			value, err := parseValue(lines[j], e.fields, valueCount)
			if err != nil {
				return EnumType{}, err
			}
			e.enumValues = append(e.enumValues, value)
			valueCount++
		}
	}

	return e, nil
}

func parseEnumName(line string) string {
	enumName := strings.TrimPrefix(line, EnumCommentStart)

	return strings.ReplaceAll(enumName, " ", "")
}

func parseField(line string) (FieldType, error) {
	fieldLine := strings.TrimPrefix(line, FieldCommentStart)
	fieldValues := strings.Split(fieldLine, Separator)

	if len(fieldValues) != 2 {
		return FieldType{}, fmt.Errorf("%s should containe name and type", line)
	}

	nameAsString := SanitizeFieldName(fieldValues[0])
	typeAsString := strings.TrimSpace(fieldValues[1])

	if _, ok := typesAndConverters[typeAsString]; !ok {
		return FieldType{}, fmt.Errorf("%s is not a supported type", typeAsString)
	}

	return FieldType{
		Name: nameAsString,
		Type: typeAsString,
	}, nil
}

func parseValue(line string, fields FieldTypes, ordinal int) (EnumValue, error) {
	valueLine := strings.TrimPrefix(line, ValueCommentStart)
	values := strings.Split(valueLine, Separator)
	vals := values[1:]
	enumName := SanitizeEnumName(values[0])
	fieldVals := make([]FieldValue, 0)
	fieldVals = append(fieldVals, getDefaultValues(ordinal, enumName)...)

	for k := DefaultFieldCount; k < len(fields); k++ {
		parsedValue, err := convert(fields[k].Type, strings.TrimSpace(vals[k-DefaultFieldCount]))
		if err != nil {
			return EnumValue{}, err
		}
		fieldVals = append(fieldVals, FieldValue{
			Name:  fields[k].Name,
			Value: parsedValue,
		})
	}

	return EnumValue{
		Name:   enumName,
		fields: fieldVals,
	}, nil
}
