package main

import (
	"fmt"
	"go/parser"
	"go/token"
	"strings"
)

const (
	EnumCommentStart  = "Enum: "
	FieldCommentStart = "Field: "
	ValueCommentStart = "Value: "
	GeneratedMessage  = "Code generated by Genum DO NOT EDIT"
	Separator         = "->"
)

func parseSource(sourceFilePath string) ([]EnumType, error) {
	parsedFile, err := parser.ParseFile(token.NewFileSet(), sourceFilePath, nil, parser.ParseComments)
	if err != nil {
		return nil, err
	}
	parsedEnums := make([]EnumType, 0)
	for _, comment := range parsedFile.Comments {
		enums, err := commentToEnumType(comment.Text())
		if err != nil {
			return nil, err
		}
		parsedEnums = append(parsedEnums, enums...)
	}

	return parsedEnums, nil
}

func commentToEnumType(comment string) ([]EnumType, error) {
	enums := make([]EnumType, 0)
	lines := strings.Split(comment, "\n")
	for i := 0; i < len(lines); i++ {
		if strings.HasPrefix(lines[i], EnumCommentStart) {
			e := EnumType{
				fields:     make(FieldTypes, 0),
				enumValues: make(EnumValues, 0),
			}
			e.addDefaultTypes()
			e.name = parseEnumName(lines[i])
			PrintSuccess(fmt.Sprintf("%s type is found", e.name))
			valueCount := 0
			for j := i + 1; j < len(lines); j++ {
				if strings.HasPrefix(lines[j], FieldCommentStart) {
					field, err := parseField(lines[j])
					if err != nil {
						return nil, err
					}
					e.fields = append(e.fields, field)
				} else if strings.HasPrefix(lines[j], ValueCommentStart) {
					value, err := parseValue(lines[j], e.fields, valueCount)
					if err != nil {
						return nil, err
					}
					e.enumValues = append(e.enumValues, value)
					valueCount++
				}
			}
			enums = append(enums, e)
		}
	}

	return enums, nil
}

func parseEnumName(line string) string {
	enumName := strings.TrimPrefix(line, EnumCommentStart)

	return strings.ReplaceAll(enumName, " ", "")
}

func parseField(line string) (FieldType, error) {
	fieldLine := strings.TrimPrefix(line, FieldCommentStart)
	fieldValues := strings.Split(fieldLine, Separator)

	if len(fieldValues) != 2 {
		return FieldType{}, fmt.Errorf("%s should containe name and type", line)
	}

	nameAsString := SanitizeFieldName(fieldValues[0])
	typeAsString := strings.TrimSpace(fieldValues[1])

	if _, ok := typesAndConverters[typeAsString]; !ok {
		return FieldType{}, fmt.Errorf("%s is not a supported type", typeAsString)
	}

	return FieldType{
		Name: nameAsString,
		Type: typeAsString,
	}, nil
}

func parseValue(line string, fields FieldTypes, ordinal int) (EnumValue, error) {
	valueLine := strings.TrimPrefix(line, ValueCommentStart)
	values := strings.Split(valueLine, Separator)
	vals := values[1:]
	enumName := SanitizeEnumName(values[0])
	fieldVals := make([]FieldValue, 0)
	fieldVals = append(fieldVals, getDefaultValues(ordinal, enumName)...)

	for k := DefaultFieldCount; k < len(fields); k++ {
		parsedValue, err := convert(fields[k].Type, strings.TrimSpace(vals[k-DefaultFieldCount]))
		if err != nil {
			return EnumValue{}, err
		}
		fieldVals = append(fieldVals, FieldValue{
			Name:  fields[k].Name,
			Value: parsedValue,
		})
	}
	return EnumValue{
		Name:   enumName,
		fields: fieldVals,
	}, nil
}
