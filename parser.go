package main

import (
	"errors"
	"go/parser"
	"go/token"
	"strings"
)

const (
	EnumCommentStart  = "Enum: "
	FieldCommentStart = "Field: "
	ValueCommentStart = "Value: "
	GeneratedMessage  = "Code generated by genum DO NOT EDIT"
)

func parseSource(sourceFilePath string) ([]EnumType, error) {
	parsedFile, err := parser.ParseFile(token.NewFileSet(), sourceFilePath, nil, parser.ParseComments)
	if err != nil {
		return nil, err
	}
	parsedEnums := make([]EnumType, 0)
	for _, comment := range parsedFile.Comments {
		enumType, err := commentToEnumType(comment.Text())
		if err != nil {
			PrintError(err.Error())
			continue
		}
		parsedEnums = append(parsedEnums, enumType)
	}

	return parsedEnums, nil
}

func commentToEnumType(comment string) (EnumType, error) {
	lines := strings.Split(comment, "\n")
	e := EnumType{
		fields:     make(FieldTypes, 0),
		enumValues: make(EnumValues, 0),
	}

	e.addDefaultTypes()
	for i := 0; i < len(lines); i++ {
		if strings.HasPrefix(lines[i], EnumCommentStart) {
			enumName := strings.TrimPrefix(lines[i], EnumCommentStart)
			e.name = strings.ReplaceAll(enumName, " ", "")
			fieldCount := 0
			for j := i + 1; j < len(lines); j++ {
				if strings.HasPrefix(lines[j], FieldCommentStart) {
					field := strings.TrimPrefix(lines[j], FieldCommentStart)
					split := strings.Split(field, " -> ")
					if len(split) >= 2 {
						e.fields = append(e.fields, FieldType{
							Name: split[0],
							Type: split[1],
						})
					} else {
						return EnumType{}, errors.New("sd")
					}
				} else if strings.HasPrefix(lines[j], ValueCommentStart) {
					values := strings.TrimPrefix(lines[j], ValueCommentStart)
					split := strings.Split(values, " -> ")
					vals := split[1:]
					fieldLength := len(e.fields)
					fieldVals := make([]FieldValue, 0)
					fieldVals = append(fieldVals, getDefaultValues(fieldCount, split[0])...)
					fieldCount++
					for k := DefaultFieldCount; k < fieldLength; k++ {
						a, err := convert(e.fields[k].Type, vals[k-DefaultFieldCount])
						if err != nil {
							return e, err
						}
						fieldVals = append(fieldVals, FieldValue{
							Name:  e.fields[k].Name,
							Value: a,
						})
					}
					e.enumValues = append(e.enumValues, EnumValue{
						Name:   split[0],
						fields: fieldVals,
					})
				}
			}
		}
	}

	return e, nil
}
